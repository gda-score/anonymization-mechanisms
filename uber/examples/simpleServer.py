#!/usr/bin/python3

"""
server.py listens for incoming requests from the client and extracts the parameters from the url sent by the client.
It then writes the extracted parameters to a file in JSON format.
It waits for the Uber Tool to write the noisy result to a file and reads the file.
It sends the result back to the client.
"""

import json
import pathlib
import time

from random import randint

from flask import Flask, request
from flask_restful import Api, Resource


app = Flask(__name__)
api = Api(app)

file_count = -1

# The path where simpleServer.py creates files containing JSON request data
request_path = pathlib.Path.cwd().parent.joinpath(pathlib.Path("files", "jsonreq"))

# The path where Uber Tool creates the result.txt files
uber_path = pathlib.Path.cwd().parent.joinpath(pathlib.Path("files", "noisyres"))


def set_file_count():
    global file_count
    file_count = len(list(uber_path.glob('result*.txt')))


def file_count_matches():
    return file_count == len(list(uber_path.glob('result*.txt')))


# Method to read .txt files generated by Uber Tool
def read_file(sid=None):
    # Check if new '*.txt' has been generated by Uber Tool
    file_lst = list(uber_path.glob('result*.txt'))
    if file_count != len(file_lst):
        latest_file = max(file_lst, key=lambda f: f.stat().st_ctime)  # Get the latest file by timestamp
        print(f"Session {sid if sid is not None and sid else 'undefined'}: "
              f"Reading result file with most recent inode metadata changes (oldest ctime): {latest_file.absolute()}")
        with open(latest_file, "r") as infile:  # Read the latest file to get the query result and return it
            return infile.readlines()
    return None


def wait_file(sid=None):
    # Calls read_file method continuously to check if query_result value has changed
    waited = 0
    while True:
        qr = read_file(sid=sid)  # Store the returned query_result
        if qr is not None:  # Check if query result value is not None
            return qr  # Return the query result
        else:
            if waited > 0 == waited % 60:
                print(f"Session {sid if sid is not None and sid else 'undefined'}: "
                      f"Server waiting for Uber Tool. "
                      f"Already waited for {waited} seconds. "
                      f"If you think this is too long for the query of this session, you should restart the services.")
            waited += 5
            time.sleep(5)


# Method to write Client request (url parameters) in JSON to a file
def write_file(response, sid):
    if sid is None or not sid:
        raise ValueError(f"Session ID cannot be empty or None. It is necessary for writing the request file.")
    # Write JSON to file
    outpath = request_path.joinpath(f"data{sid}.json")
    with open(outpath, 'w') as outfile:
        json.dump(response, outfile)
    print(f"Session {sid}: JSON Request written to: {outpath.absolute()}")


""" Server method to handle incoming data.
Calls writeFile method to write the url parameters in JSON to a file.
Returns the query result (Noisy Result) as response to Client.
"""


class GetParams(Resource):
    @staticmethod
    def request_json():
        def req_to_str(req):
            return f"url={{{req.url}}}\n" \
                   f"headers={{\n" \
                   f"{req.headers}\n" \
                   f"}}\n" \
                   f"data={{\n" \
                   f"{req.data}\n" \
                   f"}}"
        if not request.is_json:
            raise ValueError(f"Request is not valid JSON:\n{req_to_str(request)}")
        client_json = request.get_json()
        if client_json is None:
            raise ValueError(f"Failed to parse request as JSON:\n{req_to_str(request)}")
        print(f"JSON sent by client: {client_json}")
        return client_json

    @staticmethod
    def handle_query(sid, query, initial_budget, epsilon, dbname):
        if sid is None or not sid:
            sid = randint(0, 1000000000)  # Generate Session ID for new session
            used_budget = float(epsilon)  # Initialize used_budget to 0.0
            print(f"Session {sid}: New session started")
        else:
            inpath = request_path.joinpath(f"data{sid}.json")
            with open(inpath, "r") as infile:
                data = json.load(infile)

            if data is None:
                raise FileNotFoundError(f"Session {sid}: Did not find existing request file: {inpath.absolute()}")

            # Extract the previous value of used_budget and update the value by adding Epsilon value to it
            used_budget = float(data["used_budget"]) + float(epsilon)

            # Extract the original budget and restrict the Client from changing the budget
            initial_budget = data['budget']
            dbname = data['dbname']

        # Create client request
        client_request = {
            'query': query,
            'budget': initial_budget,
            'epsilon': epsilon,
            'sid': sid,
            'used_budget': used_budget,
            'dbname': dbname
        }

        # If used_budget exceeds the threshold initial_budget raise an error
        if float(initial_budget) < used_budget:
            remaining = float(initial_budget) - float(data["used_budget"])
            raise ValueError(f"Session {sid}: Budget Exceeded - Cannot process query. Remaining budget is {remaining}, "
                             f"query requires {float(epsilon)}.")

        set_file_count()  # Must count before writing updates
        write_file(client_request, sid)
        result = wait_file(sid=sid)
        result = result[0]

        if (epsilon is None or not epsilon or float(epsilon) == 0.0) and not query:
            result = ''

        # If an error/exception is contained in the Uber Tool results raise an error
        if 'error' in result.lower() or 'exception' in result.lower():
            raise ValueError(f"Session {sid}: Error/Exception in Uber Tool result: {result}")

        print(f"Session {sid}: Returning result={{{result}}}")
        result_json = {
            "Server Response": {
                "Remaining Budget": float(initial_budget) - used_budget,
                "Result": result,
                "Session ID": sid
            }
        }
        return result_json

    def handle_get(self):
        client_json = self.request_json()  # Stores the request in JSON format

        # Extract the values from the JSON payload sent by Client
        sid = client_json['sid']  # Session ID
        query = client_json['query']  # Query
        initial_budget = client_json['budget']  # Initial budget value
        epsilon = client_json['epsilon']  # Epsilon value
        dbname = client_json['dbname']  # Database name

        print(f"Session {sid if sid is not None and sid else 'undefined'}: Client provided epsilon: {epsilon}")
        if (epsilon is None or not epsilon or float(epsilon) == 0.0) and query:
            raise ValueError(f"Epsilon cannot be 0.0 for a non-empty query.")

        # If the Uber tool still processes a request of a previously connected client, we need to wait
        if file_count_matches():
            print(f"Session {sid if sid is not None and sid else 'undefined'}: "
                  f"Must wait for result of previously connected client.")
            _ = wait_file()
            print(f"Session {sid if sid is not None and sid else 'undefined'}: "
                  f"Ignoring result of previously connected client.")

        # Otherwise, handle the request in the existing session
        return self.handle_query(sid, query, initial_budget, epsilon, dbname)

    def get(self):
        try:
            result_json = self.handle_get()
        except Exception as e:
            print(f"An error occurred: {repr(e)}")
            result_json = {
                "Server Response": {
                    'Error': repr(e),
                }
            }
        return result_json


api.add_resource(GetParams, '/data')  # Route for get()

if __name__ == '__main__':
    app.run(host='139.19.217.24', port=5002)
